{"version":3,"sources":["webpack://elementBehaviors/webpack/bootstrap","webpack://elementBehaviors/./src/index.js","webpack://elementBehaviors/./node_modules/custom-attributes/attr.js"],"names":["BehaviorRegistry","constructor","_definedBehaviors","Map","define","name","Behavior","has","set","Error","get","window","elementBehaviors","BehaviorMap","behaviorMaps","WeakMap","Object","defineProperty","Element","prototype","thisBehaviors","HasAttribute","observers","connectedCallback","behaviors","ownerElement","changedCallback","value","disconnectedCallback","oldVal","newVal","newBehaviors","getBehaviorNames","previousBehaviors","Array","from","keys","length","removed","added","getDiff","handleDiff","string","trim","split","diff","i","l","oldBehavior","includes","push","splice","indexOf","behavior","parentNode","destroyAttributeObserver","delete","observedAttributes","isArray","fireInitialAttributeChangedCallbacks","createAttributeObserver","disconnect","observer","MutationObserver","records","record","attributeChangedCallback","attributeName","oldValue","getAttribute","observe","attributes","attributeOldValue","attributeFilter","attr","customAttributes","attachShadow","_attachShadow","args","root","call","CustomAttributeRegistry","version"],"mappings":"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EAAoC;AAChC,QAAMC,gBAAgB3D,QAAQC,SAAR,CAAkByD,YAAxC;;AAEA1D,UAAQC,SAAR,CAAkByD,YAAlB,GAAiC,UAAS,GAAGE,IAAZ,EAAkB;AAC/C,UAAMC,OAAOF,cAAcG,IAAd,CAAmB,IAAnB,EAAyB,GAAGF,IAA5B,CAAb;;AACA,UAAMP,aAAa,IAAIU,uBAAJ,CAA4BF,IAA5B,CAAnB;AAEAR,eAAWnE,MAAX,CAAmB,KAAnB,EAA0BiB,YAA1B;AAEA,WAAO0D,IAAP;AACH,GAPD;AAQH,C,CAED;AACA;;;AACO,MAAMG,UAAU,OAAhB,C;;;;;;AC7NP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,CAAC","file":"global.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import 'custom-attributes/attr.js'\n\nclass BehaviorRegistry {\n    constructor() {\n        this._definedBehaviors = new Map\n    }\n\n    define( name, Behavior ) {\n        if (! this._definedBehaviors.has( name )) {\n            this._definedBehaviors.set( name, Behavior )\n        }\n        else {\n            throw new Error( `Behavior ${ name } is already defined.` )\n        }\n    }\n\n    get(name) {\n        return this._definedBehaviors.get( name )\n    }\n\n    has( name ) {\n        return this._definedBehaviors.has( name )\n    }\n}\n\nwindow.elementBehaviors = new BehaviorRegistry\n\n// for semantic purpose\nclass BehaviorMap extends Map {}\n\n// stores the behaviors associated to each element.\nconst behaviorMaps = new WeakMap\n\n// All elements have a `behaviors` property. If null, it the element has no\n// behaviors, otherwise the property is a map of behavior names to behavior\n// instances.\nObject.defineProperty( Element.prototype, 'behaviors', {\n    get() {\n        let thisBehaviors = null;\n\n        if ( ! behaviorMaps.has( this ) ) {\n            behaviorMaps.set( this, thisBehaviors = new BehaviorMap )\n        }\n        else thisBehaviors = behaviorMaps.get( this )\n\n        return thisBehaviors\n    },\n} )\n\n// One instance of is instantiated per element with has=\"\" attribute.\nclass HasAttribute {\n    constructor() {\n        // TODO constructor confusing because this.ownerElement doesn't exist. Report to custom-attributes\n\n        this.observers = new Map\n    }\n\n    connectedCallback() {\n        this.behaviors = this.ownerElement.behaviors\n        this.changedCallback( '', this.value )\n    }\n\n    disconnectedCallback() {\n        this.changedCallback( this.value, '' )\n        delete this.behaviors\n    }\n\n    changedCallback( oldVal, newVal ) {\n        const newBehaviors = this.getBehaviorNames( newVal )\n        const previousBehaviors = Array.from( this.behaviors.keys() )\n\n        // small optimization: if no previous or new behaviors, just quit\n        // early. It would still function the same without this.\n        if ( newBehaviors.length == 0 && previousBehaviors.length == 0 ) return\n\n        const { removed, added } = this.getDiff( previousBehaviors, newBehaviors )\n        this.handleDiff( removed, added )\n    }\n\n    getBehaviorNames( string ) {\n        if ( string.trim() == '' ) return []\n        else return string.split( /\\s+/ )\n    }\n\n    getDiff( previousBehaviors, newBehaviors ) {\n        const diff = {\n            removed: [],\n            added: newBehaviors,\n        }\n\n        for ( let i=0, l=previousBehaviors.length; i<l; i+=1 ) {\n            const oldBehavior = previousBehaviors[ i ]\n\n            // if it exists in the previousBehaviors but not the newBehaviors, then\n            // the node was removed.\n            if (! diff.added.includes( oldBehavior ) ) {\n                diff.removed.push( oldBehavior )\n            }\n\n            // otherwise the old value also exists in the set of new values, so\n            // therefore it wasn't added or removed, so let's remove it so we\n            // don't count it as added\n            else {\n                diff.added.splice( diff.added.indexOf(oldBehavior), 1 )\n            }\n        }\n\n        return diff\n    }\n\n    handleDiff( removed, added ) {\n\n        for ( const name of removed ) {\n            if ( ! elementBehaviors.has( name ) ) continue\n\n            const behavior = this.behaviors.get( name )\n\n            // TODO fire this disconnectedCallback only if the element is in a\n            // document, not if it merely has a parent (the naive easy way for\n            // now).\n            if ( this.ownerElement.parentNode ) {\n                behavior.disconnectedCallback()\n            }\n\n            // We can't rely on checking observedAttributes here because that\n            // could change after the fact, we only ever check it when we add\n            // the behavior. If it had observedAttributes, then it will have an\n            // observer.\n            if ( this.observers.has( behavior ) ) {\n                this.destroyAttributeObserver( behavior )\n            }\n\n            this.behaviors.delete( name )\n        }\n\n        for ( const name of added ) {\n            if ( ! elementBehaviors.has( name ) ) continue\n\n            const Behavior = elementBehaviors.get( name )\n            const behavior = new Behavior( this.ownerElement )\n            this.behaviors.set( name, behavior )\n\n            // read observedAttributes first, in case anything external fires\n            // logic in the getter and expects it to happen before any\n            // lifecycle methods (f.e. a library like SkateJS)\n            const observedAttributes = behavior.constructor.observedAttributes\n\n            // TODO fire this connectedCallback only if the element is in a\n            // document, not if it merely has a parent (the naive easy way for\n            // now).\n            if ( this.ownerElement.parentNode ) {\n                behavior.connectedCallback()\n            }\n\n            if ( Array.isArray( observedAttributes ) ) {\n                this.fireInitialAttributeChangedCallbacks( behavior )\n                this.createAttributeObserver( behavior )\n            }\n        }\n    }\n\n    destroyAttributeObserver( behavior ) {\n        this.observers.get( behavior ).disconnect()\n        this.observers.delete( behavior )\n    }\n\n    // Behaviors observe attribute changes, implemented with MutationObserver\n    //\n    // We have to create one observer per behavior because otherwise\n    // MutationObserver doesn't have an API for disconnecting from a single\n    // element, only for disconnecting from all elements.\n    createAttributeObserver( behavior ) {\n        const observer = new MutationObserver( records => {\n\n            for ( const record of records ) {\n                behavior.attributeChangedCallback(\n                    record.attributeName,\n                    record.oldValue,\n                    this.ownerElement.getAttribute( record.attributeName )\n                )\n            }\n\n        } )\n\n        observer.observe( this.ownerElement, {\n            attributes: true,\n            attributeOldValue: true,\n            attributeFilter: behavior.constructor.observedAttributes\n        } )\n\n        this.observers.set( behavior, observer )\n    }\n\n    fireInitialAttributeChangedCallbacks( behavior ) {\n        if (! Array.isArray( behavior.constructor.observedAttributes ) ) return\n\n        for ( const attr of Array.from( this.ownerElement.attributes ) ) {\n            if ( ! behavior.constructor.observedAttributes.includes( attr.name ) ) continue\n            if ( behavior.attributeChangedCallback )\n                behavior.attributeChangedCallback( attr.name, null, attr.value )\n        }\n    }\n}\n\ncustomAttributes.define( 'has', HasAttribute )\n\nif (Element.prototype.attachShadow) {\n    const _attachShadow = Element.prototype.attachShadow\n    \n    Element.prototype.attachShadow = function(...args) {\n        const root = _attachShadow.call(this, ...args)\n        const attributes = new CustomAttributeRegistry(root)\n        \n        attributes.define( 'has', HasAttribute )\n        \n        return root\n    }\n}\n\n// Leave this last line alone, it gets automatically updated when publishing a\n// new version of this package.\nexport const version = '2.1.0'\n","(function () {\n'use strict';\n\nvar forEach = Array.prototype.forEach;\n\nclass CustomAttributeRegistry {\n  constructor(ownerDocument){\n    if(!ownerDocument) {\n      throw new Error(\"Must be given a document\");\n    }\n\n    this.ownerDocument = ownerDocument;\n    this._attrMap = new Map();\n    this._elementMap = new WeakMap();\n    this._observe();\n  }\n\n  define(attrName, Constructor) {\n    this._attrMap.set(attrName, Constructor);\n    this._upgradeAttr(attrName);\n  }\n\n  get(element, attrName) {\n    var map = this._elementMap.get(element);\n    if(!map) return;\n    return map.get(attrName);\n  }\n\n  _getConstructor(attrName){\n    return this._attrMap.get(attrName);\n  }\n\n  _observe(){\n    var customAttributes = this;\n    var root = this.ownerDocument;\n    var downgrade = this._downgrade.bind(this);\n    var upgrade = this._upgradeElement.bind(this);\n\n    this.observer = new MutationObserver(function(mutations){\n      forEach.call(mutations, function(m){\n        if(m.type === 'attributes') {\n          var attr = customAttributes._getConstructor(m.attributeName);\n          if(attr) {\n            customAttributes._found(m.attributeName, m.target, m.oldValue);\n          }\n        }\n        // chlidList\n        else {\n          forEach.call(m.removedNodes, downgrade);\n          forEach.call(m.addedNodes, upgrade);\n        }\n      });\n    });\n\n    this.observer.observe(root, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeOldValue: true\n    });\n  }\n\n  _upgradeAttr(attrName, document) {\n    document = document || this.ownerDocument;\n\n    var matches = document.querySelectorAll(\"[\" + attrName + \"]\");\n\n    // Use a forEach as Edge doesn't support for...of on a NodeList\n    forEach.call(matches, function(match) {\n      this._found(attrName, match);\n    }, this);\n  }\n\n  _upgradeElement(element) {\n    if(element.nodeType !== 1) return;\n\n    // Use a forEach as Safari 10 doesn't support for...of on NamedNodeMap (attributes)\n    forEach.call(element.attributes, function(attr) {\n      if(this._getConstructor(attr.name)) {\n        this._found(attr.name, element);\n      }\n    }, this);\n\n    this._attrMap.forEach(function(constructor, attr) {\n      this._upgradeAttr(attr, element);\n    }, this);\n  }\n\n  _downgrade(element) {\n    var map = this._elementMap.get(element);\n    if(!map) return;\n\n    map.forEach(function(inst) {\n      if (inst.disconnectedCallback) {\n        inst.disconnectedCallback();\n      }\n    }, this);\n\n    this._elementMap.delete(element);\n  }\n\n  _found(attrName, el, oldVal) {\n    var map = this._elementMap.get(el);\n    if(!map) {\n      map = new Map();\n      this._elementMap.set(el, map);\n    }\n\n    var inst = map.get(attrName);\n    var newVal = el.getAttribute(attrName);\n    if(!inst) {\n      var Constructor = this._getConstructor(attrName);\n      inst = new Constructor();\n      map.set(attrName, inst);\n      inst.ownerElement = el;\n      inst.name = attrName;\n      inst.value = newVal;\n      if(inst.connectedCallback) {\n        inst.connectedCallback();\n      }\n    }\n    // Attribute was removed\n    else if(newVal == null) {\n      if(inst.disconnectedCallback) {\n        inst.disconnectedCallback();\n      }\n\n      map.delete(attrName);\n    }\n    // Attribute changed\n    else if(newVal !== inst.value) {\n      inst.value = newVal;\n      if(inst.changedCallback) {\n        inst.changedCallback(oldVal, newVal);\n      }\n    }\n\n  }\n}\n\nvar customAttributes = new CustomAttributeRegistry(document);\n\nwindow.customAttributes = customAttributes;\nwindow.CustomAttributeRegistry = CustomAttributeRegistry;\n\n}());\n"],"sourceRoot":""}